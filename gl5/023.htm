<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="uk">
<link rel=Edit-Time-Data href=../tmp/vol5_3_7_u.files/editdata.mso>
<title>5.3.7. Протокол надійної доставки TCP-повідомлень</title>
</head>
<body>
<h3>5.3.7.
Протокол надійної доставки TCP-повідомлень</h3>
<p>Протокол IP є дейтаграмним
протоколом і тому по своїй природі не може гарантувати надійність передачі
даних. Це задача - забезпечення надійного
каналу обміну даними між прикладними процесами в складеній
мережі - вирішує протокол TCP (Transmission
Control Protocol), що відноситься до
транспортного рівня.</p>
<p>Протокол TCP працює безпосередньо
над протоколом IP і використовує для
транспортування своїх блоків даних потенційно
ненадійний протокол IP. Надійність передачі даних протоколом TCP досягається за
рахунок того, що він заснований на встановленні логічних з'єднань між взаємодіючими процесами. Доти поки
програми протоколу TCP продовжують функціонувати коректно, а складена мережа не
розпалася на незв'язні частини, помилки в передачі даних на рівні протоколу IP
не будуть впливати на правильне одержання даних.</p>
<p>Протокол IP використовується протоколом TCP як транспортний засіб. Перед відправленням своїх блоків даних
протокол TCP поміщає їх в оболонку IP-пакета.
При необхідності протокол IP здійснює будь-яку фрагментацію й зборку блоків даних
TCP, що вимагається для здійснення передачі й доставки через множину мереж і
проміжних шлюзів.</p>
<p>На мал. 5.22 показано, як
процеси, що виконуються на двох кінцевих вузлах, установлюють
за допомогою протоколу TCP надійний зв'язок
через складену мережу,
всі вузли якої використовуються для передачі
повідомлень дейтаграмним протокол IP.</p>
<table border="0" width="100%" id="table1">
	<tr>
		<td align="center">
		<img width=466 height=354 src=images/im022.jpg alt="Мал. 5.22. TCP-з'єднання створює надійний канал зв'язку між кінцевими вузлами"></td>
	</tr>
	<tr>
		<td align="center">Мал. 5.22. TCP-з'єднання
створює надійний канал зв'язку між кінцевими
вузлами</td>
	</tr>
</table>
<h4>Порти</h4>
<p>Протокол TCP взаємодіє через міжрівневі інтерфейси з
нижче лежачим протоколом IP і з вище лежачими
протоколами прикладного рівня або додатками.</p>
<p>У той час як завданням мережевого
рівня, до якого належить
протокол IP, є передача даних між довільними
вузлами мережі, завдання
транспортного рівня, що вирішує протокол TCP, полягає
в передачі даних між будь-якими <i>прикладними процесами, що </i>виконуються на
будь-яких вузлах мережі. Дійсно, після того як
пакет засобами протоколу IP доставлений у
комп'ютер-одержувач, дані необхідно направити конкретному процесу-одержувачеві.
Кожний комп'ютер може виконувати кілька
процесів, більш того, прикладний процес теж
може мати кілька точок входу, що виступають як
адреса призначення для пакетів даних.</p>
<p>Пакети, що надходять на транспортний рівень, організуються
операційною системою у вигляді безлічі черг до
точок входу різних прикладних процесів. У
термінології TCP/IP такі системні черги називаються <i>портами. </i>Таким
чином, адресою призначення, що використовується
протоколом TCP, є ідентифікатор (номер) порту
прикладної служби. Номер порту в сукупності з
номером мережі й номером кінцевого вузла
однозначно визначають прикладний процес у мережі. Цей набір ідентифікуючих параметрів має назву 
<b><i>сокет</i></b>
(<b><i>socket</i></b>).</p>
<p>Призначення номерів портів
прикладним процесам здійснюється або <i>централізовано, </i>якщо ці процеси
являють собою популярні загальнодоступні служби (наприклад, номер 21
закріплений за службою віддаленого доступу до
файлів FTP, a 23 — за службою віддаленого управління telnet), або локально для тих служб, які
ще не стали настільки розповсюдженими, щоб
закріплювати за ними стандартні
(зарезервовані) номери. Централізоване
присвоєння службам номерів портів виконується організацією <i>Internet Assigned
Numbers Authority (IANA). </i>Ці номери потім закріплюються й опубліковуються в
стандартах Internet (RFC 1700).</p>
<p><i>Локальне </i>присвоєння номера порту полягає в тім, що
розроблювач деякого додатка просто зв'язує з
ним будь-який доступний,
довільно обраний числовий ідентифікатор,
звертаючи увагу на те, щоб він не входив до числа зарезервованих номерів
портів. Надалі всі віддалені запити до даного
додатка від інших додатків повинні адресуватися із вказівкою
призначеного йому номера порту.</p>
<p>Протокол TCP веде для кожного порту дві
черги: чергу пакетів, що надходять у даний порт із мережі,
і чергу пакетів, що відправляються даним
портом у мережу. Процедура обслуговування
протоколом TCP запитів, що надходять від декількох різних прикладних служб, називається 
<i>мультиплексуванням.
</i>Зворотна процедура розподілу протоколом TCP поступаючих
від мережевого рівня пакетів між набором високорівневих служб, ідентифікованих
номерами портів, називається <i>демультиплексуванням
</i>(мал. 5.23).</p>
<table border="0" width="100%" id="table2">
	<tr>
		<td align="center">
		<img width=404 height=514 src=images/im023.jpg alt="Мал. 5.23. Функції протоколу TCP по мультиплексуванню й демультиплексуванню потоків"></td>
	</tr>
	<tr>
		<td align="center">Мал. 5.23. Функції протоколу TCP по мультиплексуванню й демультиплексуванню
потоків</td>
	</tr>
</table>
<h4>Сегменти й потоки</h4>
<p>Одиницею даних протоколу TCP є <i>сегмент. </i>Інформація, що надходить до протоколу TCP у рамках логічного з'єднання від протоколів більш
високого рівня, розглядається протоколом TCP як неструктурований <i>потік </i>байтів.
Дані, що надходять, буферизуються засобами TCP. Для передачі на мережевий рівень із буфера «вирізьблюється» деяка
безперервна частина даних, що і називається
сегментом (див. мал. 5.23). На відміну від
багатьох інших протоколів, протокол TCP підтверджує одержання не пакетів, а
байтів потоку.</p>
<p>Не всі сегменти, послані через з'єднання,
будуть того самого розміру, однак обидва
учасника з'єднання повинні домовитися про максимальний розмір сегмента, що вони
будуть використовувати. Цей розмір вибирається
таким чином, щоб при впакуванні сегмента в
IP-пакет він вміщався туди цілком, тобто
максимальний розмір сегмента не повинен перевершувати максимального розміру
поля даних IP-пакета. У протилежному випадку довелося б виконувати фрагментацію, тобто ділити сегмент на кілька частин, щоб розмістити його в IP-пакеті.</p>
<h4>З'єднання</h4>
<p>Для організації надійної передачі
даних передбачається встановлення <i>логічного з'єднання
</i>між двома прикладними процесами. Оскільки з'єднання
встановлюються через ненадійну комунікаційну систему, засновану
на протоколі IP, те щоб уникнути помилкової ініціалізації з'єднань використовується
спеціальна багатокрокова процедура підтвердження зв'язку.</p>
<p>З'єднання в протоколі TCP ідентифікується парою
повних адрес обох взаємодіючих процесів - сокетів.
Кожний із взаємодіючих процесів може брати
участь у декількох з'єднаннях.</p>
<p>Формальне з'єднання можна визначити як
набір параметрів, що характеризує процедуру обміну даними між двома процесами.
Крім повних адрес процесів цей набір включає й параметри, значення яких визначаються в результаті переговорного
процесу модулів TCP двох сторін з'єднання. До таких параметрів відносяться, зокрема, погоджені розміри сегментів,
які може посилати кожна зі сторін, обсяги даних, які дозволено
передавати без одержання на них підтвердження, початкові й поточні номери
переданих байтів. Деякі із цих параметрів залишаються постійними протягом усього сеансу зв'язку, а деякі
адаптивно змінюються.</p>
<p>У рамках з'єднання
здійснюється обов'язкове підтвердження правильності прийому
для всіх переданих повідомлень і при необхідності виконується повторна
передача. З'єднання в TCP дозволяє вести передачу даних одночасно в обидва боки, тобто повнодуплексну передачу.</p>
<p>Реалізація ковзного вікна в протоколі TCP</p>
<p>У рамках встановленого з'єднання правильність передачі кожного сегмента
повинна підтверджуватися квитанцією одержувача. <i>Квітірування
</i>— це один із традиційних методів
забезпечення надійного зв'язку. У протоколі TCP використається
окремий випадок квітірування - алгоритм ковзного вікна. Ідея цього алгоритму була викладена
в главі 2, «Основи передачі дискретних даних».</p>
<p>Особливість використання
алгоритму ковзауючого вікна в протоколі TCP
полягає в тому, що, хоча одиницею переданих даних є
сегмент, вікно визначене на множині
нумерованих байтів неструктурованого потоку даних, що надходять
із верхнього рівня і які буферизуються протоколом
TCP. Модуль TCP, що одержує, відправляє
«вікно» модулю, що посилає, TCP. Дане вікно
задає кількість байтів (починаючи з номера байта, про яке
вже була вислана квитанція), що приймаючий модуль TCP готовий у даний момент
прийняти.</p>
<p>Квитанція (підтвердження) посилається
тільки у випадку правильного прийому даних,
негативні квитанції не посилаються. Таким чином, відсутність квитанції означає
або прийом перекрученого сегмента, або втрату
сегмента, або втрату квитанції. Як квитанція
одержувач сегмента відсилає відповідне повідомлення (сегмент), у яке поміщає
число, на одиницю перевищуючий максимальний номер байта в отриманому сегменті.
Це число часто називають <i>номером черги.</i></p>
<p>На мал. 5.24 показаний потік
байтів, що надходить на вхід протоколу TCP. З
потоку байтів модуль TCP нарізає послідовність сегментів. Для визначеності на
малюнку прийнятий напрямок
переміщення даних з право на ліво. У цьому потоці можна вказати кілька логічних
границь. Перша границя
відокремлює сегменти, які вже були відправлені й на які вже прийшли квитанції. Наступну частину потоку становлять сегменти, які також уже відправлені, тому
що входять у границі, певного
вікна, але квитанції на них поки не отримані. Третя частина потоку - це
сегменти, які поки не відправлені, але можуть бути відправлені, тому що входять
у межі вікна. І нарешті, остання границя
вказує на початок послідовності сегментів, жоден з яких не може бути
відправлений доти, поки не прийде чергова квитанція й вікно не буде заміщено вправо.</p>
<table border="0" width="100%" id="table3">
	<tr>
		<td align="center">
		<img width=471 height=336 src=images/im024.jpg alt="Мал. 5.24. Особливості реалізації алгоритму ковзаючого вікна в протоколі TCP"></td>
	</tr>
	<tr>
		<td align="center">Мал. 5.24. Особливості реалізації алгоритму ковзаючого вікна в протоколі TCP</td>
	</tr>
</table>
<p>Якщо розмір вікна дорівнює W, а
остання за часом квитанція містила значення N,
то відправник може посилати нові сегменти доти, поки в черговий сегмент не
потрапить байт із номером N+W. Цей сегмент виходить за рамки вікна, і передачу
в такому випадку необхідно призупинити до приходу наступної квитанції.</p>
<p>Надійність передачі досягається
завдяки підтвердженням і номерам черги.
Концептуально кожному байту даних привласнюється номер черги. Номер черги для першого
байта даних у сегменті передається разом із цим сегментом і називається номером
черги для сегмента. Сегменти також несуть номер підтвердження, що є номером для наступного очікуваного байта даних, переданого у зворотному напрямку.
Коли протокол TCP передає сегмент із даними, він поміщає його копію в чергу
повторної передачі й запускає таймер. Коли приходить підтвердження для цих
даних, що відповідає сегмент віддаляється із
черги. Якщо підтвердження не приходить до закінчення терміну, то сегмент
посилає повторно.</p>
<p>Вибір часу очікування (тайм-ауту) чергової квитанції є важливим завданням,
результат рішення якої впливає на
продуктивність протоколу TCP. Тайм-аут не повинен бути занадто коротким, щоб по можливості виключити надлишкові
повторні передачі, які знижують корисну пропускну здатність
системи. Але він не повинен бути й занадто великим,
щоб уникнути тривалих простоїв, пов'язаних з очікуванням
неіснуючої або «заблудлої» квитанції.</p>
<p>При виборі величини тайм-ауту повинні враховуватися швидкість і
надійність фізичних ліній зв'язку, їхня довжина
й багато інших подібних факторів. У протоколі TCP тайм-аут визначається за допомогою досить складного
адаптивного алгоритму, ідея якого полягає в наступному. При кожній передачі
засікається час від моменту відправлення сегмента до приходу квитанції про його
прийом (час оберту).
Одержувані значення часу оберту усреднюються з
ваговими коефіцієнтами, що зростають від попереднього виміру до наступному. Це
робиться для того, щоб підсилити вплив останніх вимірів. Як тайм-аут
вибирається середній час оберту, помножене на деякий коефіцієнт. Практика показує, що
значення цього коефіцієнта повинне перевищувати 2. У мережах
з великим
розкидом часу оберту при виборі тайм-ауту
враховується й дисперсія цієї величини.</p>
<p>Оскільки кожний
байт пронумерований, то кожен з них може бути
пізнаний. Прийнятний механізм упізнавання є накопичувальним,
тому впізнавання номера <b>X</b> означає, що всі байти з
попередніми номерами вже отримані.</p>
<p>Цей механізм дозволяє реєструвати
появу дублікатів в умовах повторної передачі.
Нумерація байтів у межах сегмента здійснюється так, щоб перший байт даних відразу слідом за заголовком мав найменший
номер, а наступні за ним байти мали номера по зростанню.</p>
<p>Вікно, що посилається з кожним сегментом, визначає
діапазон номерів черги, які відправник вікна
(він же одержувач даних) готовий прийняти в цей час. Передбачається,
що такий механізм пов'язаний з наявністю в цей момент місця в буфері даних.</p>
<p>Варіюючи величину
вікна, можна впливати на завантаження мережі.
Чим більше вікно, тим більшу порцію
непідтверджених даних можна послати в мережу.
Але якщо прийшла велика кількість даних, чим може бути прийнято
програмою TCP, дані будуть відкинуті. Це приведе
до зайвих пересилань інформації й непотрібному збільшенню навантаження на мережу й програму TCP.</p>
<p>З іншого боку, визначення вікна малого розміру може обмежити
передачу даних швидкістю, що визначається
часом подорожі по мережі кожного сегмента, що
посилається. Щоб уникнути застосування малих вікон, одержувачеві
даних пропонується відкладати зміну вікна доти, поки вільне місце не складе
20-40 % від максимально можливого обсягу
пам'яті для цього з'єднання. Але й відправникові не варто поспішати
з посилкою даних, поки вікно не стане досить великим. З огляду на ці міркування,
розробники протоколу TCP запропонували схему, відповідно до якої при
встановленні з'єднання заявляється велике
вікно, але згодом його розмір істотно зменшується.</p>
<p>Якщо мережа
не справляється з навантаженням, то виникають черги в проміжних вузлах-маршрутизаторах і в
кінцевих вузлах-комп'ютерах.</p>
<p>При переповненні прийомного буфера кінцевого вузла «перевантажений» протокол TCP, відправляє квитанцію,
поміщає в неї новий, зменшений розмір вікна.
Якщо він зовсім відмовляється від прийому, то
у квитанції вказується вікно нульового розміру. Однак навіть після цього додаток може послати повідомлення на порт, що
відмовився від прийому. Для цього повідомлення повинне супроводжуватися
позначкою «терміново». У такій ситуації порт зобов'язаний прийняти сегмент,
навіть якщо для цього потрібно витиснути з
буфера ті данні, що там перебувають. Після прийому квитанції з
нульовим значенням вікна протокол-відправник час від часу робить контрольні
спроби продовжити обмін даними. Якщо протокол-приймач уже готов приймати
інформацію, то у відповідь на контрольний запит він посилає квитанцію із вказівкою ненульового розміру вікна.</p>
<p>Іншим проявом перевантаження мережі є
переповнення буферів у маршрутизаторах. У таких випадках вони можуть
централізовано змінити розмір вікна, посилаючи керуючі повідомлення деяким
кінцевим вузлам, що дозволяє їм диференційовано управляти
інтенсивністю потоку даних у різних частинах мережі.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="table1">
  <tr>
    <td width="100%" align="left" colspan="3"><hr color="#2D4C54" size="4"></td>
  </tr>
  <tr>
    <td width="33%" align="left"><a href="022.htm">Попередня</a></td>
    <td width="33%" align="center"><a href="001.htm">Перша</a></td>
    <td width="34%" align="right"><a href="024.htm">Наступна</a></td>
  </tr>
</table></body>
</html>
