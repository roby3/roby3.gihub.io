<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Language" content="uk">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>2.2.3. Логічне кодування</title>

<!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:Categories msdt:dt="string">Навчальний метеріал</mso:Categories>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head>

<body>

<h3>2.2.3. Логічне кодування</h3>
<p>Логічне кодування використовується для поліпшення потенційних кодів типу AMI, 
NRZI чи 2Q1B. Логічне кодування повинно заміняти довгі послідовності біт, що 
приводять до постійного потенціалу, вкрапленнями одиниць. Як уже відзначалося 
вище, для логічного кодування характерні два методи — надлишкові коди і 
скрэмблювання.</p>
<h4>Надлишкові коди</h4>
<p>Надлишкові коди засновані на розбивці вихідної послідовності біт на порції, 
що часто називають символами. Потім кожен вихідний символ заміняється на новий, 
котрий має більшу кількість біт, чим вихідний. Наприклад, логічний код 4В/5В, 
використовуваний у технологіях FDDI і Fast Ethernet, заміняє вихідні символи 
довжиною в 4 біти на символи довжиною в 5 біт. Тому що результуючі символи 
містять надлишкові біти, то загальна кількість бітових комбінацій у них більше, 
ніж у вихідних. Так, у коді 4В/5В результуючі символи можуть містити 32 бітові 
комбінації, у той час як вхідні символи — тільки 16. Тому в результуючому коді 
можна відібрати 16 таких комбінацій, що не містять великої кількості нулів, а 
інші вважати <i>забороненими кодами</i> (<i>code violation</i>). Крім усунення 
постійної складової і придання коду властивості самосинхронізації, надлишкові 
коди дозволяють приймачу розпізнавати спотворені біти. Якщо приймач приймає 
заборонений код, виходить, на лінії відбулося спотворення сигналу.</p>
<p>Відповідність вихідних і результуючих кодів 4В/5В представлено нижче.</p>
<table BORDER="1" CELLSPACING="1" CELLPADDING="2">
  <tr>
    <th VALIGN="TOP">Вхідний код</th>
    <th VALIGN="TOP">Результуючий<br>
    код</th>
    <th VALIGN="TOP">Вхідний<br>
    код</th>
    <th VALIGN="TOP">Результуючий<br>
    код</th>
  </tr>
  <tr>
    <td VALIGN="TOP">0000</td>
    <td VALIGN="TOP">00001</td>
    <td VALIGN="TOP">1000</td>
    <td VALIGN="TOP">10010</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0001</td>
    <td VALIGN="TOP">01001</td>
    <td VALIGN="TOP">1001</td>
    <td VALIGN="TOP">10011</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0010</td>
    <td VALIGN="TOP">10100</td>
    <td VALIGN="TOP">1010</td>
    <td VALIGN="TOP">10110</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0010</td>
    <td VALIGN="TOP">10101</td>
    <td VALIGN="TOP">1011</td>
    <td VALIGN="TOP">10111</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0100</td>
    <td VALIGN="TOP">01010</td>
    <td VALIGN="TOP">1100</td>
    <td VALIGN="TOP">11010</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0101</td>
    <td VALIGN="TOP">01011</td>
    <td VALIGN="TOP">1101</td>
    <td VALIGN="TOP">11011</td>
  </tr>
  <tr>
    <td VALIGN="TOP">1010</td>
    <td VALIGN="TOP">00101</td>
    <td VALIGN="TOP">1110</td>
    <td VALIGN="TOP">11100</td>
  </tr>
  <tr>
    <td VALIGN="TOP">0111</td>
    <td VALIGN="TOP">00101</td>
    <td VALIGN="TOP">1111</td>
    <td VALIGN="TOP">11101</td>
  </tr>
</table>
<p>Код 4В/5В потім передається по лінії за допомогою фізичного кодування по 
одному з методів потенційного кодування, чуттєвому тільки до довгих 
послідовностей нулів. Символи коду 4В/5В довжиною 5 біт гарантують, що при 
будь-якім їхньому сполученні на лінії не можуть зустрітися більш трьох нулів 
підряд.</p>
<p>Буква В в назві коду означає, що елементарний сигнал має 2 стани — від 
англійського binary — двійковий. Маються також коди і з трьома станами сигналу, 
наприклад, у коді 8В/6Т для кодування 8 біт вхідної інформації використовується 
код з 6 сигналів, кожний з який має три стани. Надмірність коду 8В/6Т вище, ніж 
коду 4В/5В, тому що на 256 вхідних кодів приходиться 3<sup>6</sup>=729 
результуючих символів.</p>
<p>Використання таблиці перекодування є дуже простою операцією, тому цей підхід 
не ускладнює мережні адаптери і інтерфейсні блоки комутаторів і маршрутизаторів.</p>
<p>Для забезпечення заданої пропускної здатності лінії передавач, що 
використовує надлишковий код, повинний працювати з підвищеною тактовою частотою. 
Так, для передачі кодів 4В/5В зі швидкістю 100 Мб/с передавач повинен працювати 
з тактовою частотою 125&nbsp;МГц. При цьому спектр сигналу на лінії розширюється в 
порівнянні з випадком, коли по лінії передається чистий, не надлишковий код. 
Проте спектр надлишкового потенційного коду виявляється вже спектром 
манчестерського коду, що виправдує додатковий етап логічного кодування, а також 
роботу приймача і передавача на підвищеній тактовій частоті.</p>
<h4>Скремблювання</h4>
<p>Перемішування даних скремблером перед передачею їх у лінію за допомогою 
потенційного коду є іншим способом логічного кодування.</p>
<p>Методи скрэмблювання полягають у побітному обчисленні результуючого коду на 
підставі біт вхідного коду й отриманих у попередніх тактах біт результуючого 
коду. Наприклад, скремблер може реалізовувати наступне співвідношення:<br>
<img border="0" src="images/f1.gif" width="298" height="40"></p>
<p>де B<sub>i</sub> — двікова цифра результуючого коду, отримана на i-м такті 
роботи скремблера, А, — двійкова цифра вхідного коду, що надходить на i-му такті 
на вхід скремблера, В<sub>і-з</sub> і В<sub>i-5</sub> — двійкові цифри 
результуючого коду, отримані на попередніх тактах роботи скремблера, відповідно 
на 3 і на 5 тактах раніше поточного такту,
<img border="0" src="images/ff.gif" align="middle" hspace="3" width="30" height="31">— операція що 
виключючого <b>АБО</b> (додавання по модулю 2).</p>
<p>Наприклад, для вихідної послідовності 110110000001 скремблер дасть наступний 
результуючий код:</p>
<p>B<sub>1</sub> = A<sub>1</sub> = 1 (перші три цифри результуючого коду будуть 
збігатися з вхідним, тому що ще немає потрібних попередніх цифр)<br>
B<sub>2</sub> = А<sub>2</sub> = 1<br>
B<sub>3</sub> = А<sub>3</sub> = О<br>
<img border="0" src="images/f2.gif" width="400" height="318"></p>
<p>Таким чином, на виході скремблера з'явиться послідовність 110001101111, у 
якій немає послідовності із шести нулів, що була присутньою у вхідному коді.</p>
<p>Після одержання результуючої послідовності приймач передає її дескремблеру, 
що відновлює вхідну послідовність на підставі зворотного співвідношення:<br>
<img border="0" src="images/f3.gif" width="400" height="23"></p>
<p>Різні алгоритми скремблювання відрізняються кількістю додатків, що дають 
цифру результуючого коду, і зрушенням між додатками. Так, у мережах ISDN при 
передачі даних від мережі до абонента використовується перетворення зі 
зрушеннями в 5 і 23 позиції, а при передачі даних від абонента в мережу — зі 
зрушеннями 18 і 23 позиції.</p>
<p>Існують і більш прості методи боротьби з послідовностями одиниць, також 
відносяться до класу скремблювання.</p>
<p>Для поліпшення коду Bipolar AMI використовуються два методи, засновані на 
штучному перекручуванні послідовності нулів забороненими символами.</p>
<p>На мал. 2.17 показане використання методу B8ZS (Bipolar with 8-Zeros 
Substitution) і методу HDB3 (High-Density Bipolar 3-Zeros) для коректування коду 
AMI. Вихідний код складається з двох довгих послідовностей нулів: у першому 
випадку — з 8, а в другому — з 5.</p>
<p>Код B8ZS виправляє тільки послідовності, що складаються з 8 нулів. Для цього 
він після перших трьох нулів замість п'яти нулів, що залишилися, вставляє п'ять 
цифр: V-1*-0-V-1*. V тут позначає сигнал одиниці, забороненої для даного такту 
полярності, тобто сигнал, що не змінює полярність попередньої одиниці, 1* — 
сигнал одиниці коректної полярності, а знак зірочки визначає той факт, що у 
вхідному коді в цьому такті була не одиниця, а нуль. У результаті на 8 тактах 
приймач спостерігає 2 перекручування — дуже малоймовірно, що це случилося через 
шум на лінії чи інших збоїв передачі. Тому приймач вважає такі порушення 
кодуванням 8 послідовних нулів і після прийому заміняє їх на вихідні 8 нулів. 
Код B8ZS побудований так, що його постійна складова дорівнює нулю при будь-яких 
послідовностях двійкових цифр.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="100%" align="center"><img border="0" src="images/m2_17.gif" width="500" height="404"></td>
  </tr>
  <tr>
    <td width="100%" align="center">Мал.2.17. Коди B8ZS і HDB3. V - сигнал 
    одиниці забороненої полярності; 1*- сигнал одиниці корегуючи полярності, але 
    замінюючи 0 в вхідному коді ) </td>
  </tr>
</table>
<p>Код HDB3 виправляє будь-які чотири підряд йдуть нуля у вхідній послідовності. 
Правила формування коду HDB3 більш складні, чим коди B8ZS. Кожні чотири нулі 
заміняються чотирма сигналами, у яких мається один сигнал V. Для придушення 
постійної складової полярність сигналу V чергується при послідовних замінах. 
Крім того, для заміни використовуються два зразки чотирьохтактових кодів. Якщо 
перед заміною вихідний код містив непарне число одиниць, то використовується 
послідовність 000V, а якщо число одиниць було парним — послідовність 1*00V.</p>
<p>Поліпшені потенційні коди мають досить вузьку смугу пропущення для будь-яких 
послідовностей одиниць і нулів, що зустрічаються в даних, що передаються. На 
мал. 2.18 приведені спектри сигналів різних кодів, отримані при передачі 
довільних даних, у яких різні сполучення нулів і одиниць у вхідному коді 
рівноімовірно. При побудові графіків спектр усреднювався по всіх можливих 
наборах вхідних послідовностей. Природно, що результуючі коди можуть мати й 
інший розподіл нулів і одиниць. З мал.&nbsp;2.18 видно, що потенційний код NRZ має 
гарний спектр з одним недоліком — у нього мається постійна складова. Коди, 
отримані з потенційного шляхом логічного кодування, мають більш вузький спектр, 
чим манчестерський, навіть при підвищеній тактовій частоті (на малюнку спектр 
коду 4В/5В повинний був би приблизно збігатися з кодом B8ZS, але він зміщений в 
область більш високих частот, тому що його тактова частота підвищена на 1/4 у 
порівнянні з іншими кодами). Цим порозумівається застосування потенційних 
надлишкових і скрембльованих кодів у сучасних технологіях, подібних FDDI, Fast&nbsp;Ethernet, 
Gigabit&nbsp;Ethernet, ISDN і т.п. замість манчестерського і біполярного імпульсного 
кодування.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber2">
  <tr>
    <td width="100%" align="center"><img border="0" src="images/m2_18.gif" width="500" height="246"></td>
  </tr>
  <tr>
    <td width="100%" align="center">Мал.2.18. потенціальних і імпульсних 
    сигналів</td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber4">
  <tr>
    <td width="100%" align="left" colspan="3"><hr color="#2D4C54" size="4"></td>
  </tr>
<tr>
    <td width="33%" align="left"><a href="008.htm">Попередня</a></td>
    <td width="33%" align="center"><a href="001.htm">Перша</a></td>
    <td width="34%" align="right"><a href="010.htm">Наступна</a></td>
  </tr>
</table>

</body>

</html>
