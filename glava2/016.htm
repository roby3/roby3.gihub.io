<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Language" content="uk">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>2.3.4. Виявлення і корекція помилок</title>

<!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:Categories msdt:dt="string">Навчальний метеріал</mso:Categories>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head>

<body>

<h3>2.3.4. Виявлення і корекція помилок</h3>
<p>Канальний рівень повинний виявляти помилки передачі даних, 
зв'язані з перекручуванням біт у прийнятому кадрі даних з втратою кадру, і по 
можливості їх коректувати. Більша частина протоколів канального рівня виконує 
тільки першу задачу — виявлення помилок, вважаючи, що коректувати помилки, тобто 
повторно передавати дані, що містили перекручену інформацію, повинні протоколи 
верхніх рівнів. Так працюють такі популярні протоколи локальних мереж, як 
Ethernet, Token&nbsp;Ring, FDDI і інші. Однак існують протоколи канального рівня, 
наприклад LLC2 чи LAP-B, що самостійно вирішують задачу відновлення перекручених 
чи загублених кадрів.</p>
<p>Очевидно, що протоколи повинні працювати найбільше ефективно в типових умовах 
роботи мережі. Тому для мереж, у яких перекручування і втрати кадрів є дуже 
рідкими подіями, розробляються протоколи типу Ethernet, у яких не передбачаються 
процедури усунення помилок. Дійсно, наявність процедур відновлення даних 
зажадало б від кінцевих вузлів додаткових обчислювальних витрат, що в умовах 
надійної роботи мережі були б надлишковими.</p>
<p>Навпроти, якщо в мережі перекручування і втрати трапляються часто, то бажано 
вже на канальному рівні використовувати протокол з корекцією помилок, а не 
залишати цю роботу протоколам верхніх рівнів. Протоколи верхніх рівнів, 
наприклад транспортного чи прикладного, працюючи з великими тайм-аутами, 
відновлять загублені дані з великою затримкою. У глобальних мережах перших 
поколінь, наприклад мережах Х.25, що працювали через ненадійні канали зв'язку, 
протоколи канального рівня завжди виконували процедури відновлення загублених і 
перекручених кадрів.</p>
<p>Тому не можна вважати, що один протокол краще іншого тому, що він відновлює 
помилкові кадри, а інший протокол — ні. Кожен протокол повинен працювати в тих 
умовах, для яких він розроблений.</p>
<h4>Методи виявлення помилок</h4>
<p>Усі методи виявлення помилок засновані на передачі в складі кадру даних 
службової надлишкової інформації, по якій можна судити з деяким ступенем 
імовірності про вірогідність прийнятих даних. Цю службову інформацію прийнято 
називати <i>контрольною сумою</i> (чи <i>послідовністю контролю кадру</i> — 
Frame Check Sequence, FCS). Контрольна сума обчислюється як функція від основної 
інформації, причому необов'язково тільки шляхом підсумовування. Приймаюча 
сторона повторно обчислює контрольну суму кадру по відомому алгоритмі й у 
випадку її збігу з контрольною сумою, обчисленою передавальною стороною, робить 
висновок про те, що дані були передані через мережу коректно.</p>
<p>Існує кілька розповсюджених алгоритмів обчислення контрольної суми, що 
відрізняються складністю обчислень і здатністю виявляти помилки в даних.</p>
<p><i>Контроль по паритету</i> являє собою найбільш простий метод контролю 
даних. У той же час це найменш могутній алгоритм контролю, тому що з його 
допомогою можна знайти тільки одиночні помилки в даних, що перевіряються. Метод 
полягає в підсумовуванні по модулі 2 всіх біт контрольованої інформації. 
Наприклад, для даних 100101011 результатом контрольного підсумовування буде 
значення 1. Результат підсумовування також являє собою один біт даних, що 
пересилається разом з контрольованою інформацією. При перекручуванні при 
пересиланні будь-якого одного біта вихідних даних (чи контрольного розряду) 
результат підсумовування буде відрізнятися від прийнятого контрольного розряду, 
що говорить про помилку. Однак подвійна помилка, наприклад 110101010, буде 
невірно прийнята за коректні дані. Тому контроль по паритету застосовується до 
невеликих порцій даних, як правило, до кожного байта, що дає коефіцієнт 
надмірності для цього методу 1/8. Метод рідко застосовується в обчислювальних 
мережах через його велику надмірність і невисокі діагностичні здібності.</p>
<p><i>Вертикальний і горизонтальний контроль по паритету</i> являє собою 
модифікацію описаного вище методу. Його відмінність полягає в тому, що вихідні 
дані розглядаються у вигляді матриці, рядки якої складають байти даних. 
Контрольний розряд підраховується окремо для кожного рядка і для кожного стовпця 
матриці. Цей метод виявляє велику частину подвійних помилок, однак має ще більшу 
надмірність. На практиці зараз також майже не застосовується.</p>
<p><i>Циклічний надлишковий контроль</i> (<i>Cyclic Redundancy Check, CRC</i>) 
зраз є найбільш популярним методом контролю в обчислювальних мережах (і не 
тільки в мережах, наприклад, цей метод широко застосовується при записі даних на 
диски і дискети). Метод заснований на розгляді вихідних даних у вигляді одного 
багато розрядного двійкового числа. Наприклад, кадр стандарту Ethernet, що 
складає з 1024 байт, буде розглядатися як одне число, що складається з 8192 біт. 
Як контрольну інформацію розглядається залишок від розподілу цього числа на 
відомий дільник R. Звичайно як дільник вибирається сімнадцяти чи тридцяти трьох 
розрядне число, щоб залишок від поділу мав довжину 16 розрядів (2 байт) чи 32 
розряду (4 байт). При одержанні кадру даних знову обчислюється залишок від 
поділу на той же дільник R, але при цьому до даних кадру додається і контрольна 
сума, що міститься в ньому. Якщо залишок від поділу на R дорівнює нулю (Існує 
трохи модифікована процедура обчислення залишку, що приводить до одержання у 
випадку відсутності помилок відомого ненульового залишку, що є більш надійним 
показником коректності.), то робиться висновок про відсутність помилок в 
отриманому кадрі, в противному випадку кадр вважається перекрученим.</p>
<p>Цей метод має більш високу обчислювальну складність, але його діагностичні 
можливості набагато вище, ніж у методів контролю по паритету. Метод CRC виявляє 
всі одиночні помилки, подвійні помилки і помилки в непарному числі біт. Метод 
має також невисокий ступінь надмірності. Наприклад, для кадру Ethernet розміром 
у 1024 байт контрольна інформація довжиною в 4 байт складає тільки 0,4 %.</p>
<h4>Методи відновлення перекручених і загублених кадрів</h4>
<p>Методи корекції помилок в обчислювальних мережах засновані на повторній 
передачі кадру даних у тому випадку, якщо кадр губиться і не доходить до 
адресата або приймач знайшов в ньому перекручування інформації. Щоб переконатися 
в необхідності повторної передачі даних, відправник нумерує кадри, що 
відправляються,&nbsp; для кожного кадру очікує від приймача так названої <i>
позитивної квитанції</i> - службового кадру, що сповіщає про те, що вихідний 
кадр був отриманий і дані в ньому виявилися коректними. Час цього чекання 
обмежено — при відправленні кожного кадру передавач запускає таймер, і, якщо по 
його час пройшов і позитивна квитанція на отримана, кадр вважається загубленим. 
Приймач у випадку одержання кадру з перекрученими даними може відправити <i>
негативну квитанцію</i> — явна вказівка на те, що даний кадр потрібно передати 
повторно.</p>
<p>Існують два підходи до організації процесу обміну квитанціями: із простоями і 
з організацією &quot;вікна&quot;.</p>
<p><i>Метод з простоями</i> (<i>Idle Source</i>) вимагає, щоб джерело, що 
послало кадр, очікувало одержання квитанції (позитивної чи негативний) від 
приймача і тільки після цього посилало наступний кадр (чи повторювало 
перекручений). Якщо ж квитанція не приходить протягом тайм-ауту, то кадр (чи 
квитанція) вважається загубленим і його передача повторюється. На мал.&nbsp;2.24,&nbsp;а 
видно, що в цьому випадку продуктивність обміну даними істотно знижується, — 
хоча передавач і міг би послати наступний кадр відразу ж після відправлення 
попереднього, він зобов'язаний чекати приходу квитанції. Зниження продуктивності 
цього методу корекції особливо помітно на низькошвідкісних каналах зв'язку, 
тобто в територіальних мережах.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="100%" align="center"><img border="0" src="images/m2_24.gif" width="575" height="571"></td>
  </tr>
  <tr>
    <td width="100%" align="center">Мал. 2.24&nbsp; Методи поновлення 
    перекручених і загублених кадрів</td>
  </tr>
</table>
<p>Другий метод називається методом <i>&quot;ковзаючого вікна&quot;</i> sliding window). В 
цьому методі для підвищення коефіцієнта використання лінії джерелу дозволяється 
передати деяку кількість кадрів у безупинному режимі, тобто в максимально 
можливому для джерела темпі, без одержання на ці кадри позитивних відповідних 
квитанцій. (Далі, де це не спотворює вислови, позитивні квитанції для стислості 
будуть називатися просто &quot;квитанціями&quot;.) Кількість кадрів, що дозволяється 
передавати таким чином, називається розміром вікна. Малюнок&nbsp;2.24,&nbsp;б ілюструє 
даний метод для вікна розміром у W кадрів.</p>
<p>У початковий момент, коли ще не послано жодного кадру, вікно визначає 
діапазон кадрів з номерами від 1 до W включно. Джерело починає передавати кадри 
й одержувати у відповідь квитанції. Для простоти припустимо, що квитанції 
надходять у тій же послідовності, що і кадри, яким вони відповідають. У момент t<sub>1</sub> 
при одержанні першої квитанції К1 вікно зрушується на одну позицію, визначаючи 
новий діапазон від 2 до (W+1). Процеси відправлення кадрів і одержання квитанцій 
йдуть незалежно друг від друга. Розглянемо довільний момент часу t<sub>n</sub>, 
коли джерело одержало квитанцію на кадр із номером n. Вікно зрушилося вправо і 
визначило діапазон дозволених до передачі кадрів від (n+1) до (W+n). Всю множину 
кадрів, що виходять із джерела, можна розділити на перераховані нижче групи 
(мал.&nbsp;2.24,&nbsp;б).</p>
<ul>
  <li><i>Кадри з номерами від 1 до n</i> уже були відправлені і квитанції на них 
  отримані, тобто вони перебувають за межами вікна ліворуч.</li>
  <li><i>Кадри, починаючи з номера (n+1) і кінчаючи номером (W+n)</i>, 
  знаходяться в межах вікна і тому можуть бути відправлені не чекаючи приходу 
  якої-небудь квитанції. Цей діапазон може бути розділений ще на два 
  піддіапазона:<ul>
    <li>&nbsp;кадри з номерами від (n+1) до m, що уже відправлені, але квитанції на 
    них ще не отримані;&nbsp;</li>
    <li>кадри з номерами від m до (W+n), що поки не відправлені, хоча заборони 
    на це немає. </li>
  </ul>
  </li>
  <li><i>Всі кадри з номерами, більшими чи дорівнюючими (W+ n +1), </i>
  перебувають за межами вікна праворуч і тому поки не можуть бути відправлені.</li>
</ul>
<p>Переміщення вікна вздовж послідовності номерів кадрів показане на 
мал.&nbsp;2.24,&nbsp;в. Тут t<sub>o</sub> — вихідний момент, t<sub>1</sub> і t<sub>n</sub> 
— моменти приходу квитанцій на перший <i>і</i> <i>n-й</i> кадр відповідно. 
Щораз, коли приходить квитанція, вікно зрушується вліво, але його розмір при 
цьому не змінюється і залишається рівним W. Зауважимо, що хоча в даному прикладі 
розмір вікна в процесі передачі залишається постійним, у реальних протоколах 
(наприклад, TCP) можна зустріти варіанти даного алгоритму з розміром вікна, що 
змінюється.</p>
<p>Отже, при відправленні кадру з номером <i>n</i> джерелу дозволяється передати 
ще W-1 кадрів до одержання квитанції на кадр <i>n</i>, так що в мережу останнім 
піде кадр з номером (W + n - 1). Якщо ж за цей час квитанція на кадр <i>n</i> 
так і не прийшла, то процес передачі припиняється, і після закінчення деякого 
тайм-ауту кадр <i>n</i> (чи квитанція на нього) вважається загубленим, і він 
передається знову.</p>
<p>Якщо ж потік квитанцій надходить більш-менш регулярно, у межах допуску в W 
кадрів, то швидкість обміну досягає максимально можливої величини для даного 
каналу і прийнятого протоколу.&nbsp; Метод ковзаючого вікна більш складний у 
реалізації, чим метод із простоями, тому що передавач повинний зберігати в 
буфері всі кадри, на які поки не отримав позитивні квитанції. Крім того, 
потрібно відслідковувати кілька параметрів алгоритму: розмір вікна W, номер 
кадру, на який отримана квитанція, номер кадру, що ще можна передати до 
одержання нової квитанції.</p>
<p>Приймач може не посилати квитанції на кожен прийнятий коректний кадр. Якщо 
кілька кадрів прийшли майже одночасно, то приймач може послати квитанцію тільки 
на останній кадр. При цьому мається на увазі, що всі попередні кадри також 
дійшли благополучно.</p>
<p>Деякі методи використовують негативні квитанції. Негативні квитанції бувають 
двох типів — групові і виборчі. Групова квитанція містить номер кадру, починаючи 
з якого потрібно повторити передачу всіх кадрів, відправлених передавачем у 
мережу. Виборча негативна квитанція вимагає повторної передачі тільки одного 
кадру.</p>
<p>Метод ковзного вікна реалізований у багатьох протоколах: LLC2, LAP-B, X.25, 
TCP, Novell NCP Burst Mode.</p>
<p>Метод із простоями є наслідком методу ковзаючого вікна, коли розмір вікна 
дорівнює одиниці.</p>
<p>Метод ковзаючого вікна має два параметри, що можуть помітно впливати на 
ефективність передачі даних між передавачем і приймачем, — розмір вікна і 
величина тайм-ауту очікування квитанції. У надійних мережах, коли кадри 
спотворюються і губляться рідко, для підвищення швидкості обміну даними розмір 
вікна потрібно збільшувати, тому що при цьому передавач буде посилати кадри з 
меншими паузами. У ненадійних мережах розмір вікна варто зменшувати, тому що при 
частих втратах і перекручуваннях кадрів різко зростає обсяг вдруге переданих 
через мережу кадрів, а значить, пропускна здатність мережі буде витрачатися 
багато в чому вхолосту — корисна пропускна здатність мережі буде падати.</p>
<p>Вибір тайм-ауту залежить не від надійності мережі, а від затримок передачі 
кадрів мережею.</p>
<p>У багатьох реалізаціях методу ковзного вікна величина вікна і тайм-аут 
вибираються адаптивно, в залежності від поточного стану мережі.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber4">
  <tr>
    <td width="100%" align="left" colspan="3"><hr color="#2D4C54" size="4"></td>
  </tr>
<tr>
    <td width="33%" align="left"><a href="015.htm">Попередня</a></td>
    <td width="33%" align="center"><a href="001.htm">Перша</a></td>
    <td width="34%" align="right"><a href="017.htm">Наступна</a></td>
  </tr>
</table>

</body>

</html>
