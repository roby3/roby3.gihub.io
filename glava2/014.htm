<html xmlns:mso="urn:schemas-microsoft-com:office:office" xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882">

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Language" content="uk">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>2.3.2. Синхронні символьно-ориєнтовані й біт-орієнтовані протоколи
</title>

<!--[if gte mso 9]><xml>
<mso:CustomDocumentProperties>
<mso:Categories msdt:dt="string">Навчальний метеріал</mso:Categories>
</mso:CustomDocumentProperties>
</xml><![endif]-->
</head>

<body>

<h3>2.3.2. Синхронні символьно-ориєнтовані й біт-орієнтовані протоколи</h3>
<p>У синхронних протоколах між символами, що пересилаються, (байтами) немає 
стартових і стопових сигналів, тому окремі символи в цих протоколах пересилати 
не можна. Всі обміни даними здійснюються кадрами, що мають у загальному випадку 
заголовок, поле даних і кінцівку (мал. 2.21). Усі біти кадру передаються 
безупинним синхронним потоком, що значно прискорює передачу даних.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="100%" align="center"><img border="0" src="images/m2_21.gif" width="509" height="95"></td>
  </tr>
  <tr>
    <td width="100%" align="center">Мал.2.21 Кадри синхронних протоколів </td>
  </tr>
</table>
<p>Тому що байти в цих протоколах не відокремлюються друг від друга службовими 
сигналами, то однією з перших задач приймача є розпізнавання границі байт. Потім 
приймач повинний знайти початок і кінець кадру, а також визначити границі 
кожного поля кадру — адреси призначення, адреси джерела, інших службових полів 
заголовка, полю чи даних і контрольної суми, якщо вона мається.</p>
<p>Більшість протоколів допускає використання в кадрі поля даних перемінної 
довжини. Іноді і заголовок може мати перемінну довжину. Звичайно протоколи 
визначають максимальне значення, що може мати довжина поля даних. Ця величина 
називається <i>максимальною одиницею передачі даних</i> (<i>Maximum Transfer 
Unit, MTU</i>).&nbsp;У деяких протоколах задається також мінімальне значення, що може 
мати довжина поля даних. Наприклад, протокол Ethernet вимагає, щоб поле даних 
містило принаймні 46 байт даних (якщо додаток хоче відправити меншу кількість 
байт, то він зобов'язаний доповнити їх до 46 байт будь-якими значеннями). Інші 
протоколи дозволяють використовувати поле даних нульової довжини, наприклад FDDI.</p>
<p>Існують також протоколи з кадрами фіксованої довжини, наприклад, у протоколі 
ATM кадри фіксованого розміру 53 байт, включаючи службову інформацію. Для таких 
протоколів необхідно вирішити тільки першу частину задачі — розпізнати початок 
кадру.</p>
<p>Синхронні протоколи канального рівня бувають двох типів: 
символьно-орієнтовані (байт-орієнтовані) і біт-орієнтовані. Для обох характерні 
ті самі методи синхронізації біт. Головне розходження між ними полягає в методі 
синхронізації символів і кадрів.</p>
<h4>Символьно-ориєнтовані протоколи</h4>
<p>Символьно-ориєнтовані протоколи використовуються в основному для передачі 
блоків, які відображають символи, наприклад текстових файлів. Тому що при 
синхронній передачі немає стопових і стартових бітів, для синхронізації символів 
потрібен інший метод. Синхронізація досягається за рахунок того, що передавач 
додає два чи більш керуючих символи, які називаються символами SYN, перед кожним 
блоком символів.</p>
<p>У коді ASCII символ SYN має двійкове значення 0010110, це несиметричне 
відносно початку символу значення дозволяє легко розмежовувати окремі символи 
SYN при їхньому послідовному прийомі. Символи SYN виконують дві функції: 
по-перше, вони забезпечують приймачу побітну синхронізацію, по-друге, як тільки 
бітова синхронізація досягається, вони дозволяють приймачу почати розпізнавання 
границь символів SYN. Після того як приймач почав відокремлювати один символ від 
іншого, можна задавати границі початку кадру за допомогою іншого спеціального 
символу. Звичайно в символьних протоколах для цих цілей використовується символ 
STX (Start of TeXt, ASCII 0000010). Інший символ позначає закінчення кадру - ЕТХ 
(End of Tехt'аSСІІ 0000011).</p>
<p>Однак такий простий спосіб виділення початку і кінця кадру добре працював 
тільки в тому випадку, якщо усередині кадру не було символів STX і ЕТХ. При 
підключенні до комп'ютера алфавітно-цифрових терміналів така задача дійсно не 
виникала. Проте синхронні Символьно-ориєнтовані протоколи пізніше стали 
використовуватися і для зв'язку комп'ютера з комп'ютером, а в цьому випадку дані 
усередині кадру можуть бути будь-які, якщо, наприклад, між комп'ютерами 
передається програма. Найбільш популярним протоколом такого типу був протокол 
BSC компанії IBM. Він працював у двох режимах - непрозорому, у якому деякі 
спеціальні символи усередині кадру заборонялися, і прозорому, у якому 
дозволялася передача усередині кадру будь-яких символів, у тому числі й ЕТХ. 
Прозорість досягалася за рахунок того, що перед керуючими символами STX і ЕТХ 
завжди вставлявся символ DLE (Data Link Escape). Така процедура називається <i>
стаффінгом</i> символів (stuff - усяка всячина, заповнювач). А якщо в поле даних 
кадру зустрічалася послідовність DLE ЕТХ, то передавач подвоював символ DLE, 
тобто породжував послідовність DLE DLE ЕТХ. Приймач, зустрівши підряд два 
символи DLE DLE, завжди видаляв перший, але той що залишився DLE уже не 
розглядав як початок керуючої послідовності, тобто символи, що залишилися, DLE 
ЕТХ вважав просто користувальницькими даними.</p>
<h4>Біт-орієнтовані протоколи</h4>
<p>Потреба в парі символів на початку і кінці кожного кадру разом з додатковими 
символами DLE означає, що Символьно-орієнтована передача не ефективна для 
передачі двійкових даних, тому що приходиться в поле даних кадру додавати досить 
багато надлишкових даних. Крім того, формат керуючих символів для різних 
кодувань різний, наприклад, у коді ASCII символ SYN дорівнює 0010110, а в коді 
EBCDIC - 00110010. Так що цей метод застосовується тільки з визначеним типом 
кодування, навіть якщо кадр містить чисто двійкові дані. Щоб усунути ці 
проблеми, сьогодні майже завжди використовується більш універсальний метод, що 
називається біт-орієнтованою передачею. Цей метод зараз застосовується при 
передачі як двійкових, так і символьних даних. На мал.&nbsp;2.22 показані 3 різні 
схеми біт-орієнтованої передачі. Вони відрізняються способом позначення початку 
і кінця кожного кадру.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber2">
  <tr>
    <td width="100%" align="center"><img border="0" src="images/m2_22.gif" width="516" height="567"></td>
  </tr>
  <tr>
    <td width="100%" align="center">Мал.2.22. Способи виділення початку і кінця 
    при синхронній передачі</td>
  </tr>
</table>
<p>Перша схема, показана на мал. 2.22,&nbsp;а, схожа на схему із символами STX і ЕТХ 
у символьно-орієнтованих протоколах. Початок і кінець кожного кадру 
відзначається однієї і тією же 8-бітовою послідовністю — 01111110, яка 
називається прапором (флагом). Термін &quot;біт-орієнтований&quot; використовується тому, 
що прийнятий потік біт сканується приймачем на побітовій основі для виявлення 
стартового прапора, а потім під час прийому для виявлення стопового прапора. 
Тому довжина кадру в цьому випадку не обов'язково повинна бути кратною 8 бітам.</p>
<p>Щоб забезпечити синхронізацію приймача, передавач посилає послідовність 
байтів простою (кожний складається з 11111111), що передує стартовому прапору.
</p>
<p>Для досягнення прозорості даних у цій схемі необхідно, щоб прапор не був 
присутній у полі даного кадру. Це досягається за допомогою прийому, відомого як 
вставка 0 біта, — біт-стаффінга. Схема вставки битка працює тільки під час 
передачі&nbsp; даних кадру. Якщо ця схема виявляє, що підряд передано п'ять 1, 
то вона автоматично вставляє додатковий 0 (навіть якщо після цих п'яти 1 йшов 
0). Тому послідовність 01111110 ніколи не з'явиться в полі даних кадру. 
Аналогічна схема працює в приймачі і виконує зворотну&nbsp; функцію. Коли після 
п'яти 1 виявляється 0, він автоматично видаляється з поля даних кадру. 
Біт-стаффінг набагато економічний, чим байт-стаффінг тому що замість зайвого 
байта вставляється один біт, отже, швидкість передачі даних користувача у цьому 
випадку сповільнюється в меншому ступені.</p>
<p>В другій схемі (див. рис, 2.22, б) для позначення початку кадру мається 
тільки стартовий прапор, а для визначення кінця кадру використовується поле 
довжини кадру, що при фіксованих розмірах заголовка і кінцівки найчастіше має 
сенс довжини поля чи даних кадру. Ця схема найбільш застосовна в локальних 
мережах. У цих мережах для позначення факту незайнятості середовища у вхідному 
стані по середовищу взагалі не передається ніяких символів. Щоб всі інші станції 
ввійшли в бітову синхронізацію, що посилає станція випереджає вміст кадру 
послідовністю біт, відомої як преамбула, що складається з чергування одиниць і 
нулів 101010... Ввійшовши в бітову синхронізацію, приймач досліджує вхідний 
потік на побітовій основі, поки не знайде байт початку кадру 10101011, що 
виконує роль символу STX. За цим байтом випливає заголовок кадру, у якому у 
визначеному місці знаходиться поле довжини чи поле даних. Таким чином, у цій 
схемі приймач просто відраховує задану кількість байт, щоб визначити закінчення 
кадру.</p>
<p>Третя схема (див. мал. 2.22,&nbsp;в) використовує для позначення початку і кінця 
кадру прапори, що включають заборонені для даного коду сигнали (code violations, 
V). Наприклад, при манчестерському кодуванні замість обов'язкової зміни 
полярності сигналу в середині тактового інтервалу рівень сигналу залишається 
незмінним низької частоти (заборонений сигнал J)&nbsp; незмінним високої частоти 
(заборонений сигнал К). Початок кадру відзначається послідовністю JK0JK00, а 
кінець — послідовністю JK1JK100. Цей спосіб дуже економічний, тому що не вимагає 
ні біт-стаффінга, ні поля довжини, але його недолік полягає в залежності від 
прийнятого методу фізичного кодування. При використанні надлишкових кодів роль 
сигналів J і К грають заборонені символи, наприклад, у коді 4В/5В цими символами 
є коди 11000 і 10001.</p>
<p>Кожна з трьох схем має свої переваги і недоліки. Прапори дозволяють 
відмовитися від спеціального додаткового засобу&nbsp; але вимагають спеціальних 
засобів: або дозволу розміщення прапора в полі даних за рахунок біт-стаффінга, 
або використання, як прапора заборонених сигналів, ф це робить цю схему залежною 
від способу кодування.</p>
<h4>Протоколи з гнучким форматом кадру</h4>
<p>Для більшої частини протоколів характерні кадри, що складаються зі службових 
полів фіксованої довжини. Виключення робиться тільки для полів даних, з метою 
ощадливого пересилання як невеликих квитанцій, так і великих файлів. Спосіб 
визначення закінчення кадру шляхом завдання довжини поля даних, розглянутий 
вище, саме розрахований на такі кадри з фіксованою структурою і фіксованими 
розмірами службових полів.</p>
<p>Однак існує ряд протоколів, у яких кадри мають гнучку структуру. Наприклад, 
до таких протоколів відносяться дуже популярний прикладний протокол керування 
мережами SNMP, а також протокол канального рівня РРР, що використовується для 
з'єднань типу &quot;точка-точка&quot;. Кадри таких протоколів складаються з невизначеної 
кількості полів, кожне з який може мати перемінну довжину. Початок такого кадру 
визначається деяким стандартним образом, наприклад за допомогою прапора, а потім 
протокол послідовно переглядає поля кадру і визначає їх кількість і розміри. 
Частіше за все, кожне поле описується двома додатковими полями фіксованого 
розміру. Наприклад, якщо в кадрі зустрічається поле, що містить деякий 
символьний рядок, то в кадр вставляються три поля:</p>
<table BORDER="0" CELLSPACING="1" CELLPADDING="2" WIDTH="100%">
  <tr>
    <td WIDTH="100%" VALIGN="TOP" HEIGHT="22" colspan="3"><hr color="#000000">
    </td>
  </tr>
  <tr>
    <td WIDTH="13%" VALIGN="TOP" HEIGHT="22"><b>Тип</b></td>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="22"><b>Довжина</b></td>
    <td WIDTH="73%" VALIGN="TOP" HEIGHT="22"><b>Значення</b></td>
  </tr>
  <tr>
    <td WIDTH="100%" VALIGN="TOP" HEIGHT="20" colspan="3"><hr color="#000000">
    </td>
  </tr>
  <tr>
    <td WIDTH="13%" VALIGN="TOP" HEIGHT="20">string</td>
    <td WIDTH="14%" VALIGN="TOP" HEIGHT="20">б</td>
    <td WIDTH="73%" VALIGN="TOP" HEIGHT="20">public</td>
  </tr>
  <tr>
    <td WIDTH="100%" VALIGN="TOP" HEIGHT="20" colspan="3"><hr color="#000000">
    </td>
  </tr>
</table>
<p>Додаткові поля &quot;Тип&quot; і &quot;Довжина&quot; мають фіксований розмір в один байт, тому 
протокол легко знаходить границі поля &quot;Значення&quot;. Тому що кількість таких полів 
також невідома, для визначення загальної довжини кадру використовується або 
загальне поле &quot;Довжина&quot;, яке міститься на початку кадру і відноситься до всіх 
полів даних.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber4">
  <tr>
    <td width="100%" align="left" colspan="3"><hr color="#2D4C54" size="4"></td>
  </tr>
<tr>
    <td width="33%" align="left"><a href="013.htm">Попередня</a></td>
    <td width="33%" align="center"><a href="001.htm">Перша</a></td>
    <td width="34%" align="right"><a href="015.htm">Наступна</a></td>
  </tr>
</table>

</body>

</html>
